# 읽기/쓰기 트레이드오프를 고민해야 하는 이유

## 📌 핵심 질문

**"읽기/쓰기 트레이드오프를 고민해야 하는 이유는 락을 걸었다가 병목 현상이 발생할 수 있기 때문인가요?"**

**답변**: **네, 맞습니다!** 락으로 인한 병목 현상이 **주요 원인 중 하나**입니다. 하지만 다른 요인들도 함께 고려해야 합니다.

---

## 🎯 읽기/쓰기 트레이드오프의 핵심 원인

### 1. 락으로 인한 병목 현상 ⭐ **가장 큰 원인**

#### 문제 상황: Hot Spot (핫스팟)

```
인기 상품에 100명이 동시에 좋아요를 누름
→ 모두 같은 Product row를 업데이트하려고 함
→ 락 경쟁 발생
```

#### 컬럼 기반 방식 (비관적 락)

```java
@Transactional
public void addLike(String userId, Long productId) {
    // 100명이 동시에 이 코드 실행
    Product product = productRepository.findByIdForUpdate(productId);
    // ↑ SELECT ... FOR UPDATE → 락 획득
    
    product.incrementLikeCount();  // like_count = like_count + 1
    productRepository.save(product);
    // ↑ UPDATE product SET like_count = ... WHERE id = ?
}
```

**타임라인**:
```
T1: SELECT ... FOR UPDATE (락 획득) → like_count = 100 → UPDATE → 커밋 (락 해제)
T2: 대기... (T1이 락을 해제할 때까지)
T3: 대기... (T1이 락을 해제할 때까지)
T4: 대기... (T1이 락을 해제할 때까지)
...
T100: 대기... (T1이 락을 해제할 때까지)

→ T1이 끝나면 T2가 락 획득 → 처리 → 락 해제
→ T2가 끝나면 T3가 락 획득 → 처리 → 락 해제
...
```

**결과**:
- ❌ **순차 처리**: 100명이 순차적으로 처리됨 (병렬 처리 불가)
- ❌ **대기 시간 증가**: 평균 대기 시간 = (처리 시간 × 대기 순서)
- ❌ **처리량 감소**: 초당 처리 가능한 요청 수가 급격히 감소
- ❌ **타임아웃 발생**: 대기 시간이 너무 길어지면 타임아웃 발생

#### 테이블 분리 방식 (Insert-only)

```java
@Transactional
public void addLike(String userId, Long productId) {
    // 100명이 동시에 이 코드 실행
    Like like = Like.of(userId, productId);
    likeRepository.save(like);
    // ↑ INSERT INTO like (user_id, product_id) VALUES (?, ?)
    // → 각각 다른 row에 삽입 → 락 경쟁 없음!
}
```

**타임라인**:
```
T1: INSERT INTO like (user_id=1, product_id=100) → 성공
T2: INSERT INTO like (user_id=2, product_id=100) → 성공 (다른 row)
T3: INSERT INTO like (user_id=3, product_id=100) → 성공 (다른 row)
...
T100: INSERT INTO like (user_id=100, product_id=100) → 성공 (다른 row)

→ 모두 동시에 처리 가능! (병렬 처리)
```

**결과**:
- ✅ **병렬 처리**: 100명이 동시에 처리됨
- ✅ **대기 시간 없음**: 락 경쟁 없음
- ✅ **처리량 증가**: 초당 처리 가능한 요청 수가 크게 증가
- ✅ **확장성**: 트래픽이 증가해도 성능 저하 적음

#### 비교 예시

| 방식 | 동시 요청 100개 처리 시간 | 처리량 |
|------|------------------------|--------|
| **컬럼 기반 (비관적 락)** | ~10초 (순차 처리) | 10 req/s |
| **테이블 분리 (Insert-only)** | ~0.1초 (병렬 처리) | 1000 req/s |

**차이**: **100배 성능 차이!**

---

### 2. 쓰기 경합 (Write Contention)

#### Hot Spot 문제

**컬럼 기반 방식**:
- 하나의 row에 모든 쓰기가 집중됨
- 같은 row를 여러 트랜잭션이 동시에 수정하려고 함
- 락 경쟁 발생

**테이블 분리 방식**:
- 각 트랜잭션이 다른 row에 삽입
- 쓰기 경합 없음

#### 예시: 인기 상품 vs 비인기 상품

```
인기 상품 (product_id = 1):
- 좋아요 10,000개
- 100명이 동시에 좋아요 추가
→ 컬럼 기반: 100명이 같은 row 업데이트 → 락 경쟁 심함
→ 테이블 분리: 100명이 각각 다른 row 삽입 → 경합 없음

비인기 상품 (product_id = 2):
- 좋아요 5개
- 1명이 좋아요 추가
→ 컬럼 기반: 문제 없음
→ 테이블 분리: 문제 없음
```

**핵심**: **인기 상품일수록 락 경쟁이 심해짐**

---

### 3. 조회 성능 차이

#### 컬럼 기반 방식

```sql
-- 좋아요 수 조회
SELECT like_count FROM product WHERE id = 1;
-- → 인덱스로 바로 해당 row 조회 → 매우 빠름 (0.1ms)
```

**장점**:
- ✅ 매우 빠른 조회
- ✅ 인덱스 활용 가능

#### 테이블 분리 방식

```sql
-- 좋아요 수 조회
SELECT COUNT(*) FROM like WHERE product_id = 1;
-- → 전체 테이블 스캔 또는 인덱스 스캔 → 느림 (10ms ~ 100ms)
```

**단점**:
- ❌ COUNT(*) 연산 필요
- ❌ 좋아요가 많을수록 느려짐
- ❌ 대량 조회 시 부하 증가

#### 비교 예시

| 방식 | 조회 시간 (좋아요 10,000개) | 조회 시간 (좋아요 100,000개) |
|------|---------------------------|----------------------------|
| **컬럼 기반** | 0.1ms | 0.1ms (변화 없음) |
| **테이블 분리** | 10ms | 100ms (10배 증가) |

**차이**: **좋아요가 많을수록 성능 차이 증가**

---

### 4. 확장성 문제

#### 컬럼 기반 방식

```
트래픽 증가:
- 100 req/s → 락 경쟁 시작
- 1,000 req/s → 심각한 병목
- 10,000 req/s → 시스템 마비

→ 수평 확장 불가 (같은 row를 업데이트해야 함)
→ 수직 확장만 가능 (더 빠른 DB 서버)
```

#### 테이블 분리 방식

```
트래픽 증가:
- 100 req/s → 문제 없음
- 1,000 req/s → 문제 없음
- 10,000 req/s → 문제 없음

→ 수평 확장 가능 (샤딩 가능)
→ 수직 확장도 가능
```

---

### 5. 데이터 정합성 요구사항

#### 좋아요 수: Eventually Consistent 가능

**이유**:
- 약간의 지연 허용 가능 (1~5초)
- 정확성보다 성능이 중요
- 하이브리드 방식으로 해결 가능

**적용**:
- Insert-only로 쓰기 경합 없음
- 스케줄러로 주기적 동기화
- 조회는 캐시된 값 사용

#### 주문/포인트: Strong Consistency 필수

**이유**:
- 돈과 직접 연결된 값
- 즉시 정확한 값 필요
- 락으로 정확성 보장 필요

**적용**:
- 비관적 락 사용
- 락 경쟁 감수하고 정확성 보장

---

## 📊 종합 비교

| 원인 | 컬럼 기반 (비관적 락) | 테이블 분리 | 하이브리드 |
|------|---------------------|------------|-----------|
| **락 병목** | ❌ 심함 | ✅ 없음 | ✅ 없음 |
| **쓰기 경합** | ❌ 심함 | ✅ 없음 | ✅ 없음 |
| **조회 성능** | ✅ 빠름 | ❌ 느림 | ✅ 빠름 |
| **확장성** | ❌ 낮음 | ✅ 높음 | ✅ 매우 높음 |
| **정확성** | ✅ 즉시 | ✅ 즉시 | ⚠️ 약간 지연 |

---

## 🎯 결론

### 읽기/쓰기 트레이드오프를 고민해야 하는 이유

1. **락으로 인한 병목 현상** ⭐ **가장 큰 원인**
   - Hot Spot에서 락 경쟁 발생
   - 순차 처리로 인한 처리량 감소
   - 대기 시간 증가

2. **쓰기 경합**
   - 하나의 row에 모든 쓰기가 집중
   - 인기 상품일수록 문제 심화

3. **조회 성능 차이**
   - 컬럼 읽기 vs COUNT(*) 연산
   - 좋아요가 많을수록 성능 차이 증가

4. **확장성 문제**
   - 수평 확장 가능 여부
   - 트래픽 증가에 대한 대응력

5. **데이터 정합성 요구사항**
   - Eventually Consistent vs Strong Consistency
   - 정확성 vs 성능 트레이드오프

### 권장 사항

**좋아요 기능**:
- ✅ 테이블 분리 방식 (현재)
- ✅ 하이브리드 방식 (개선)

**주문/포인트**:
- ✅ 비관적 락 사용 (정확성 우선)

---

## 🔗 관련 문서

- [좋아요 설계 옵션 비교](./11-like-design-options.md)
- [Lock 전략 설계](./09-lock-strategy.md)
- [좋아요 설계 옵션 구현 예시](./11-like-design-options-examples.md)

