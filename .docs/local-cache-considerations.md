## 로컬 캐시 적용 고려 사항

이 문서는 `loopers-spring-java-template` 프로젝트에서 **로컬 캐시(인스턴스 메모리 캐시)** 를 어디에, 어떤 기준으로 적용할지 정리한 메모입니다.  
이미 존재하는 Redis 기반 캐시(`ProductCacheService`)와의 역할 분리를 전제로 합니다.

---

## 1. 현재 캐시 구조 요약

- **상품 목록/상세 조회**
  - `CatalogProductFacade` → `ProductCacheService` 를 통해 **Redis 캐시** 사용.
  - 상품 목록:
    - 첫 페이지(page=0)만 캐시하여 메모리 사용량을 제한.
    - 브랜드를 배치 조회하여 N+1 문제를 해소.
  - 상품 상세:
    - `productId` 기준으로 상세 정보를 Redis 에 저장.
    - `Product.likeCount`(비동기 집계 값)을 활용.
- **캐시 무효화**
  - Lua 스크립트 기반 SCAN 패턴 삭제로 `KEYS` 블로킹 문제 회피.
  - 상품 단위/브랜드 단위/전체 목록 단위 무효화 기능 제공.

이 구조는 이미 **읽기 트래픽이 큰 상품 조회 도메인**에 대해 분산 캐시를 잘 적용하고 있으며, 추가로 로컬 캐시를 덧씌울 필요성은 상대적으로 낮습니다.

---

## 2. 로컬 캐시를 검토할 만한 후보 지점

### 2.1 사용자 정보 조회 (`UserInfoFacade.getUserInfo`)

- 경로: `apps/commerce-api/src/main/java/com/loopers/application/userinfo/UserInfoFacade.java`
- 역할:
  - `userRepository.findByUserId(userId)` 로 사용자 기본 정보를 조회하는 단순 read 유즈케이스.
  - 이메일, 생년월일, 성별 등 **변경이 잦지 않은 속성** 위주.
- 로컬 캐시 후보로 적합한 이유:
  - 로그인 후 “내 정보”를 자주 조회하는 시나리오에서, 동일 `userId` 에 대한 반복 조회가 많을 수 있음.
  - 강한 실시간 일관성이 크게 요구되지 않는다면, **Caffeine 등 인스턴스 메모리 캐시 + 짧은 TTL(수 초~수 분)** 만으로 DB 부하를 효과적으로 줄일 수 있음.
- 적용 아이디어:
  - 스프링 캐시(`@Cacheable`) + Caffeine 조합으로 `userId` 기준 캐시를 구성.
  - 사용자 정보 변경 API가 있을 경우, 해당 시점에 `@CacheEvict` 또는 직접 캐시 삭제를 호출하여 키 단위로 무효화.
  - 변경 API가 아직 없다면, 초기에는 **TTL 기반 캐시만 사용**하는 형태로도 운영 가능.

### 2.2 마스터 데이터 조회 (브랜드, 쿠폰 정의 등)

- 예시 1: 브랜드 정보
  - `CatalogProductFacade` 에서 상품 목록 조회 시 브랜드를 배치 조회:
  - `brandId` → `Brand` 조회가 **읽기 비중은 높고 변경은 적은** 전형적인 마스터 데이터 패턴.
  - 인스턴스 로컬 캐시에 `brandId -> Brand` 를 몇 분 단위 TTL로 보관하면, 반복 조회 시 DB 부하를 줄일 수 있음.
- 예시 2: 쿠폰 정의 정보
  - `CouponRepository` 는 주로 쿠폰 정책/메타데이터를 다루는 도메인.
  - 쿠폰 코드 기준으로 **정적 정책**(할인율, 유효기간 등)을 조회하는 경우:
    - 정책 자체는 자주 바뀌지 않으므로, `couponCode -> Coupon` 를 로컬 캐시에 두는 것이 효율적.
  - 단, **사용자의 쿠폰 사용 이력/잔여 수량** 같이 자주 변하는 값은 로컬 캐시 대상이 아님.

### 2.3 코드/옵션/설정성 데이터

- 정렬 옵션, 코드 테이블, UI 드롭다운에 쓰는 상수 데이터 등:
  - DB 또는 설정 파일에서 읽어오지만 잘 변하지 않는 경우.
  - 여러 API에서 반복적으로 참조된다면, 인스턴스 메모리 캐시에 올려두는 것이 적합.
- 이 영역은 **분산 캐시(예: Redis)** 를 쓰기엔 오버스펙인 경우가 많고,
  - 로컬 캐시만으로도 충분한 일관성과 성능을 얻을 수 있다는 점에서 후보군에 포함.

---

## 3. 로컬 캐시를 피해야 할 영역

### 3.1 포인트/재고/주문과 같이 강한 일관성이 필요한 도메인

- 예시: `PurchasingFacade` 의 주문 생성 로직
  - 포인트 차감, 재고 차감, 주문 상태 변경에 대해 **비관적 락(PESSIMISTIC_WRITE)** 으로 동시성을 제어.
  - 금전적 손실/재고 oversell 을 막기 위해 DB 를 단일 source of truth 로 사용.
- 이 영역에 로컬 캐시(또는 Redis 캐시)를 끼워 넣으면:
  - 최신 상태와 캐시 상태가 어긋나는 순간 **치명적인 일관성 문제**가 발생할 수 있음.
  - 설계 상 DB 락을 기반으로 일관성을 맞추고 있으므로, 캐싱보다는 **쿼리/인덱스/락 범위 최적화**가 우선.

### 3.2 자주 갱신되는 카운터/집계 값의 원천 데이터

- 예: 좋아요 수, 재고 수량, 포인트 잔액 등.
  - 이미 비동기 집계된 결과(`Product.likeCount`)를 읽기 용도로 사용하는 것은 괜찮지만,
  - **원천 데이터(실제 트랜잭션 테이블)** 를 로컬 캐시로 가리는 것은 위험.
- 이런 값은 DB 또는 Redis 의 atomic 연산/락을 활용하는 것이 바람직하며,  
  로컬 캐시는 **읽기 전용으로 안전하게 캐시 가능한 파생 데이터**에만 사용하는 것을 원칙으로 한다.

---

## 4. 로컬 캐시 vs Redis 캐시 선택 기준

> 📖 **상세한 선택 기준은 [캐시 구현 방식 선택 가이드](./cache-implementation-selection-guide.md)를 참고하세요.**

- **로컬 캐시가 더 적합한 경우**
  - 노드 간 완전한 일관성이 크게 중요하지 않다.
  - 데이터 양이 많지 않고, 인스턴스 메모리에 부담 없이 올릴 수 있다.
  - 매우 빠른 응답 속도가 필요하고, 네트워크 hop(→ Redis)을 줄이고 싶다.
  - "거의 안 바뀌는" 마스터/설정성/코드성 데이터 위주다.

- **Redis(분산 캐시)가 더 적합한 경우**
  - 여러 인스턴스에서 동일한 캐시 데이터를 공유해야 한다.
  - 캐시 갱신/무효화 타이밍을 인스턴스 단위가 아니라 시스템 전체에서 맞춰야 한다.
  - 캐시 키 수가 많고, 인스턴스 메모리만으로는 감당하기 어렵다.

---

## 5. 도입 시 권장 패턴 (요약)

- **프레임워크**
  - Spring Cache 추상화(`@EnableCaching`, `@Cacheable`, `@CacheEvict`) + Caffeine 을 기본 선택지로 고려.
- **기본 전략**
  - 읽기 전용 또는 읽기 비중이 압도적으로 높은 유즈케이스에만 적용.
  - 먼저 **TTL 기반 캐시**로 시작하고, 필요 시 쓰기 경로에 `@CacheEvict` 를 추가해 세밀한 무효화 도입.
- **점진적 도입 순서**
  1. `UserInfoFacade.getUserInfo` 에 `userId` 기준 로컬 캐시 도입.
  2. 브랜드/쿠폰 등 마스터 데이터 조회에 로컬 캐시 적용.
  3. 효과를 모니터링하고, 다른 읽기 전용 코드/옵션/설정성 데이터로 범위를 확장.


