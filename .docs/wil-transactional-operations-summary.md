# 📘 WIL – Transactional Operation

## 🧠 이번 주에 새로 배운 것

동시성 문제는 "기술적 정답"이 있는 것이 아니라 읽기/쓰기 트레이드오프 + 도메인 리스크 판단이라는 걸 확실하게 이해했습니다.

"돈이 걸린 문제면 무조건 비관적 락"이라고 생각했던 제 기준이 매우 단편적이었다는 걸 깨달았습니다.

기능마다 "충돌 가능성, 충돌 시 피해 규모, 읽기/쓰기 패턴, 실시간 정합성 요구도"가 다르기 때문에 도메인별로 다른 동시성 전략이 필요하다는 걸 알게 되었습니다.

---

## 💭 이런 고민이 있었어요

주문번호 중복 이슈를 마주했을 때 "이건 돈이 걸린 문제니까 비관적 락을 거는게 정답이다"라고 생각했는데, 실제로는 결제 금액이 틀어지는 문제도 아니고 주문 결과 페이지 접근 불가라는 UX 문제일 뿐이었습니다.

동시성 문제는 결국 읽기-쓰기 패턴 중 어디에서 병목이 발생하는 것을 감수할 것인가에 대한 선택이라는 점을 깨달았습니다.

"이 기능은 읽기가 훨씬 많나, 쓰기가 훨씬 많나?", "동시에 몰릴 때, 어디에 병목이 생기는가?", "충돌이 발생했을 때, 그게 얼마나 큰 사고인가?"를 먼저 이해해야 했습니다.

도메인별로 "충돌 가능성", "충돌 시 피해 규모", "정합성 요구 수준", "읽기/쓰기 패턴"을 표로 나누어보니, 동시성을 '락으로 해결하는 문제'가 아니라 '어떤 리스크는 허용 가능하고 어떤 리스크는 절대 허용할 수 없는지 판단하는 문제'라는 사실을 실감했습니다.

인기 상품에 재고 차감 요청이 몰릴 경우, 비관적 락으로 인해 같은 row에 대한 락 경쟁이 발생하고 API 서버를 10대, 100대로 늘려도 DB 락 경쟁으로 처리량이 증가하지 않는 문제가 있었습니다.

Hot Spot 발생 시 비관적 락은 순차 처리로 10초가 걸리지만, Insert-only 패턴은 병렬 처리로 0.1초가 걸려 100배 성능 차이가 발생했습니다.

트래픽이 낮거나 중간일 때는 Pessimistic Lock을 사용하고, 트래픽이 높거나 Hot Spot 발생 시에는 Optimistic Lock 또는 Queueing을 고려해야 한다는 판단 기준을 세웠습니다.

애플리케이션 레벨로는 race condition을 완전히 방지할 수 없기 때문에, UNIQUE 제약조건이 데이터 무결성을 보장하는 가장 안전하고 비용 효율적인 옵션이라는 것을 배웠습니다.

DBA가 유니크 인덱스를 반대하는 이유는 쓰기 성능 저하, 락 경합, 장애 시 복구 비용 증가 때문이라는 점을 이해하게 되었습니다.

"해당 테이블의 쓰기 QPS가 어느 정도인지 보셨나요? 좋아요/쿠폰/포인트는 고 QPS write-heavy 테이블이 아니며, unique index가 병목을 일으킬 가능성은 거의 없습니다"라는 논리로 DBA를 설득할 수 있다는 것을 배웠습니다.

금전적 손실 가능성을 제시하면 DBA의 태도가 달라진다는 것을 경험했습니다.

DBA가 비관적 락을 반대하는 이유는 애플리케이션 장애 시 락이 유지되어 DB 전체가 멈출 수 있다는 점, 락 경합, 락 범위가 예상보다 넓다는 점 때문이라는 것을 이해하게 되었습니다.

비관적 락은 기본 전략이 아니며 전체 시스템에서 쓰는 것이 아니라, 포인트/재고/쿠폰/결제 같은 금전적 손실 위험이 있는 도메인에만 row 단위로 짧게 적용할 계획임을 명확히 전달해야 한다는 것을 배웠습니다.

트랜잭션 내부에 외부 I/O가 없고, lock holding time이 짧고, contention이 거의 없기 때문에 장애 위험이 매우 낮다는 점을 DBA에게 설득할 수 있었습니다.

예전에는 "돈 → 비관적 락", "중복 싫음 → 유니크 인덱스"처럼 머릿속에 묵직한 if 문 몇 개를 넣어두고 그걸 기준으로 판단했지만, 지금은 동시성에는 정답이 없고 각 도메인마다 "읽기/쓰기 패턴, 트래픽, 허용 가능한 리스크, 비즈니스 목표"가 있고, 그 조합에 따라 더 낫고 덜 나쁜 선택이 있을 뿐이라고 생각하게 되었습니다.

---

## 📌 앞으로 실무에 써먹을 수 있을 것 같은 포인트

동시성 문제를 볼 때 '기술'부터 떠올리지 않고, 도메인의 책임과 병목 지점을 먼저 분리해서 보는 습관이 필요하다는 걸 배웠습니다.

동시성 문제의 대안을 제시할 때 이걸 쓰면 생기는 리스크 vs 안 쓰면 생기는 리스크를 함께 비교하는 대화가 중요하다는 걸 깨달았어요.

Insert-only / 시퀀스 / MQ 직렬화 / Redis INCR 등 다양한 전략을 상황에 맞게 조합해서 사용할 수 있는 감각을 갖추는 것이 실력이라고 느꼈습니다.

트랜잭션 범위를 하나의 유즈케이스 단위로 묶어서 커밋 I/O를 최소화하고, 트랜잭션 내부에 외부 I/O가 없어야 lock holding time을 최소화할 수 있다는 것을 배웠습니다.

동시성 테스트는 3~5개 스레드로는 너무 적고, 10~30개 정도 병렬로 테스트해야 하며, 도메인 중요도에 따라 스레드 수를 조정해야 한다는 것을 배웠습니다.

JPA 낙관적 락에서 Dirty Checking 때문에 충돌 감지가 늦어질 수 있으므로, `saveAndFlush()`를 사용하여 Fast Fail을 보장해야 한다는 것을 배웠습니다.

---

## 🤔 아쉬웠던 점 & 다음 주에 해보고 싶은 것

비관적 락, MVCC, Unique 인덱스, Redis, MQ 등 각각의 동작 원리는 알고 있었지만 문제 해결 관점에서 "어떤 기준으로 써야 하는가?"를 판단하는 감각은 부족했던 것 같아요.

이번에 표로 정리해보면서 굉장히 큰 도움을 받았는데, 다른 도메인(예: 장바구니, 배송, 멤버십, 정기결제 등)에도 같은 방법을 적용해보고 싶습니다.

가능하다면 실제 부하 테스트를 돌려서 각 전략이 병목 지점에서 어떤 차이를 만드는지 체감해보고 싶습니다.

REPEATABLE READ 격리 수준에서 Phantom Read가 범위 쿼리/집계 쿼리에서 발생 가능하다는 것을 배웠는데, 실제 서비스에서 이것이 문제가 되는 케이스를 더 깊이 분석해보고 싶습니다.

---

## 📝 참고 문서

- `.docs/transactional-operation-evaluation.md`: Transactional Operation 평가 보고서
- `.docs/dba-persuasion-criteria.md`: DBA 설득을 위한 판단 기준
- `.docs/design/15-concurrency-design-principles.md`: 동시성 처리 설계 원칙
- `.docs/design/18-hotspot-pessimistic-lock-limitations.md`: Hot Spot 문제와 비관적 락의 한계
- `.docs/design/12-read-write-tradeoff-reason.md`: 읽기/쓰기 트레이드오프를 고민해야 하는 이유
- `.docs/transaction-isolation-analysis.md`: 트랜잭션 격리 수준 및 동시성 문제 분석
- `.docs/transaction-readonly-vs-unique-constraint.md`: @Transactional(readOnly = true) vs UNIQUE 제약조건
